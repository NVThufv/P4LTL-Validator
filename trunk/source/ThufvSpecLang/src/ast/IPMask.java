/* BitvecLiteral -- Automatically generated by TreeBuilder (2022-06-30T15:29Z) */

package ast;

import java.math.BigInteger;

import de.uni_freiburg.informatik.ultimate.ltl2aut.ast.AstNode;

public class IPMask extends Predicate {
	/**
     * The interface of P4Boogie for get the masked value.
     */
	final public static String MASK_INTERFACE_PREFIX = "slice_bv32_32_";
	
	/**
     * The instrument name prefix of this predicate.
     */
	final public static String INSTRUMENT_NAME_PREFIX = "_IPMASK_";
	
    /**
     * The value of ip address represent in long.
     */
	long ipAddress;

	/**
     * The value of ip address represent in String.
     */
	String ipString;
	
    /**
     * The length of valid bits.
     */
    int length;
    
    /**
     * The header to check equality.
     */
    String header;
    
    /**
     * The constructor taking initial values.
     * @param ipmask the string description of IPMask.
     */
    public IPMask(String header, String ip, BigInteger length) {
    	this.header = header;
		this.ipString = ip;
        this.ipAddress = parse_ip(ipString);
        this.length = length.intValue();
        
        assert validate(): "Not a valid ip string for " + ipString;
    }
    
    /**
     * Returns the long description of the corresponding ip string.
     */
    private static long parse_ip(String ip) {
    	String[] part = ip.split("\\.");
        long num = 0;
        for (int i = 0; i < part.length; i++) {
            int power = 3 - i;
            num += ((Integer.parseInt(part[i]) % 256 * Math.pow(256, power)));
        }
        return num;
	}
    
    /**
     * Judges whether ip is a real ip string and mask <= 32.
     * Note: Maybe is not needed for Jflex + Jcup may do the same thing.
     */
    public boolean validate() {
        String PATTERN = "^((0|1\\d?\\d?|2[0-4]?\\d?|25[0-5]?|[3-9]\\d?)\\.){3}(0|1\\d?\\d?|2[0-4]?\\d?|25[0-5]?|[3-9]\\d?)$";
        return ipString.matches(PATTERN) && length <= 32 && length >= 0;
    }
    
    /**
     * Returns a boogie description of this object.
     */
    public String toString() {
    	// Naming rule: _IPMASK_{header}_{IP}_{LSB}
    	return INSTRUMENT_NAME_PREFIX + this.header +  "_" + this.ipAddress + "_" + this.getLSB();
//    	return MASK_INTERFACE_PREFIX + this.getLSB() + "(" +  + ")";
    }
    
    /**
     * Returns the corresponding boogie expression description of this object.
     */
    public String getBoogieExpr() {
//    	String formatString = MASK_INTERFACE_PREFIX + this.getLSB() + "(%s)";
//    	String formatString = "((v-v%s)" + this.getLSB() + "(%s)";
//    	return String.format(formatString, header) + " == " + String.format(formatString, Long.toString(ipAddress));
    	return getSliceFunInvoke(header) + " == " + getSliceFunInvoke(Long.toString(ipAddress));
    }
    
    /**
     * Returns the inline boogie expression description of var[32:32-length].
     */
    private String getSliceFunInvoke(String var)
    {
    	String template = "((v-v%power_lsb)/power_lsb) % power_length";
    	template = template.replace("power_lsb", Long.toString(Math.round(Math.pow(2, getLSB()))));
    	template = template.replace("power_length", Long.toString(Math.round(Math.pow(2, getLength()))));
    	template = template.replace("v", var);
    	return template;
    }

    /**
     * Gets the ip address given as long.
     * @return the value given as long.
     */
    public long getIPAddress() {
        return ipAddress;
    }
    
    
    /**
     * Gets the ip address given as string.
     * @return the value given as string.
     */
    public String getIPString() {
        return ipString;
    }

    /**
     * Gets the number of mask bits in this IPMask.
     * @return the number of bits in this IPMask.
     */
    public int getLength() {
        return length;
    }
    
    /**
     * Gets the least significant bit of ip.
     * @return the least significant bit of ip.
     */
    public int getLSB() {
        return 32-length;
    }
    
    
    /**
     * Gets the type of this predicate.
     * @return the type of this predicate.
     */
	@Override
	public PredicateType getType()
	{
		return PredicateType.ipmask;
	}
}
